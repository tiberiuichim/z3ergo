Modalitati de rezolvare a unor probleme tipice
==============================================

Sfaturi generale
----------------
* codul sursa al Zope-ului este simplu si usor de interpretat. Daca nu exista
  documentatie, citeste codul sursa, incepand cu interfetele si apoi fisierul
  configure.zcml, pentru a intelege ce ofera acel pachet. 
* Foloseste namespace-urile
* Separa partea de "backend" de cea de "frontend" in sub-pachete-uri diferite:
  `app` si una din variantele: `browser`, `skin`, `ui`.
* Pastreaza o balanta intre necesitatea de a separa in pachete si un numar prea
  mare de pachete, cu interdependinte ridicate
* Foloseste pachetele comunitatii Zope (z3c), acestea sunt cel mai adesea mai 
  noi si mai flexibile decat cele cu care vine zope. Exemplu: z3c.form, 
  z3c.pagelet, z3c.table, etc.
* Atunci cand faci design-ul unei librarii sau componente reutilizabile, este
  foarte usor sa se creeze o infrastructura bazata pe ZCA, cu multe puncte de 
  insertie. O balanta trebuie mentinuta, pentru a nu face ca folosirea acelui
  pachet sa impuna necesitati ridicate (gen: implementeaza un adaptor pentru
  interfata asta, am nevoie de un utility pentru interfata asta, etc). Se poate
  intampla ca atunci cand dezvoltatorul sa vrea sa foloseasca componenta 
  respectiva sa ii fie mai usor sa o inlocuiasca cu totul, asa ca fii sigur ca
  asiguri cel putin un punct unic de "override", care sa faca posibila 
  inlocuirea intregului mecanism. Cu toate acestea:
* Incearca sa faci componentele general valabile, pentru a fi reutilizabile.
  Pe termen lung acesta este unul dintre avantajele folosirii Zope 3: 
  componentele sunt usor de dezvoltat astfel incat ele sa fie refolosibile
* Viewlet-urile si pageleturile sunt o idee buna, insa nu trebuiesc abuzate, 
  pentru ca necesita mai multa munca din partea dezvoltatorului.
* Nu e nevoie de o integrare foarte mare cu ZMI.   
* Nu e recomandabil designul unei aplicatii complexe fara experienta.


Folosirea interfetelor de tip marker pentru definirea capabilitatilor
---------------------------------------------------------------------
O interfata de tip marker este o interfata "goala, ce mosteneste direct 
`zope.interface.Interface`. Folosind aceste interfate pot fi definite 
capabilitati si implementarea abstractizata a acestora. Declararea de catre o 
clasa a implementarii acelei capabilitati atrage cu aceasta si beneficierea de 
implementarea acelei capabilitati. Exemplu:

Sa presupunem ca vrem sa dezvoltam o solutie reutilizabila de adaugare de 
comentarii. Fiecare comentariu va fi stocat intr-un obiect de tip IComment, iar
aceste comentarii vor fi stocate in anotarile obiectelor. Intr-un sistem de tip
CMS, pentru care tip de obiecte va fi afisat butonul "Add comment"? A lua ca 
indiciu faptul ca un obiect este anotabil nu este de ajuns: nu toate obiectele
anotabile trebuiesc sa fie comentabile. Solutia este simpla: vom crea o 
interfata marker::

    class IHasComments(Interface):
        """Pe acest tip de obiecte pot fi adaugate comentarii"""

Adapterul folosit pentru factory-ul ce genereaza anotarea obiectelor poate fi::

    class IComments(Interface):
        """Comentariile obiectului"""
    
    class Coments(BTreeContainer):
        implements(IComments)
        adapts(IHasComments)
        
        def add_comment(self, *args, **kwds):
            self[u"Comment %s" % len(self)] = Comment(*args, **kwds)
        
Daca avem un obiect de tip BlogEntry, este suficient sa il marcam ca fiind
"comentabil"::

    class BlogEntry(Persistent):
        implements(IBlogEntry, IHasComments)
    
Un viewlet care prezinta un fragment cu comentariile pe obiectul curent, plus
butonul de "Adauga comentarii" ar putea arata astfel::

    class CommentsViewlet(BaseViewlet):

        @property
        def available(self):
            return IHasComments.providedBy(self.context)
        
Iar codul care adauga comentarii poate fi pur si simplu::

    IComments(some_blog_entry).add_comment(...)
    IComments(some_other_object_type).add_comment(...)
    

Folosirea anotarilor si a relatiilor
------------------------------------ 
Avand un folder cu imagini de pe circuitele de curse de masini, dorim sa 
asignam o lista de imagini unor obiecte de tipul Pilot, Echipa sau Stadion.::

    class IHasImages(Interface):
       """marker, objects have pointers to images"""
    
    class Pilot:
       implements(IHasImages, IAttributeAnnotatable)
       #e gresit sa pui IHasImage sa faca inherit la AttributeAnnotatable
       #HasImages tine de comportament, AttributeAnnotatable tine deja de 
       #implementarea anotarilor
    
    class Team(Persistent):
       implements(IHasImages, IAttributeAnnotatable)
    
    class Stadium(Persistent):
       implements(IHasImages, IAttributeAnnotatable)
       
    class PicturesAlbum(BTreeContainer): 
       contains(IImage)
    
    class IPicturesInfo(Interface):
       images = List(title=u"Image",
                     value_type=Relation(title="Relation")
                     )
    
    class PicturesInfoAnotation(Persistent):
        implements(IPicturesInfo)
        adapts(IHasImages)
        
        images = None
       
    from zope.annotation.factory import factory
    annotation_factory = factory(PicturesInfoAnotation, 'images_pointers')

Astfel, codul ce foloseste aceasta anotare este simplu::
             
    IPicturesInfo(pilot_instance).images.append(img) 
    del IPicturesInfo(team_instance).images[1] 


Internationalizarea continutului cu z3c.language.switch
-------------------------------------------------------
::

    class BusinessI18NInfo(Persistent):
        """The business content object"""
    
        name = FieldProperty(IBusiness['name'])
        address = FieldProperty(IBusiness['address'])
        description = FieldProperty(IBusiness['description'])
        promo_message = FieldProperty(IBusiness['promo_message'])
    
    
    class Business(I18n, BTreeContainer, Contained):
        """ """
        _factory = BusinessI18NInfo
        _defaultLanguage = 'en'
    
        implements(IBusiness)
    
        name = I18nFieldProperty(IBusiness['name'])
        address = I18nFieldProperty(IBusiness['address'])
        description = I18nFieldProperty(IBusiness['description'])
        promo_message = I18nFieldProperty(IBusiness['promo_message'])
    
        def queryAttribute(self, name, language=None, default=None):
            #override so that we never return empty stuff
            value = super(Business, self).queryAttribute(name, language, default=None)
            if value is None:
                negotiator = getUtility(INegotiator, context=self)
                lang = negotiator.serverLanguage
                try:
                    value = self.getAttribute(name, language=lang)
                except KeyError:
                    pass
            if value is None:
                #try to return something meaningful
                langs = self.getAvailableLanguages()
                if langs:
                    lang = langs[0]
                try:
                    value = self.getAttribute(name, language=lang)
                except KeyError:
                    pass
            if value is not None:
                return value
            else:
                return default
            
            
Modificarea traversarii cu z3c.traverser
----------------------------------------
Traversing to business/images will return the annotation of BusinessImagesAlbum 
for the Business:

.. code-block:: xml

  <subscriber
    for="lovely.reviewportal.app.interfaces.IBusiness
         zope.publisher.interfaces.browser.IBrowserRequest"
    provides="z3c.traverser.interfaces.ITraverserPlugin"
    factory=".traversing.BussinesTraverserPlugin" />

.. code-block:: python

    class BussinesTraverserPlugin(ContainerTraverserPlugin):
        """Traverser that returns the images album at business/images/ for a Business
        """
    
        def publishTraverse(self, request, name):
            if name == "images":
                images = IBusinessImagesAlbum(self.context)
                proxied_images = LocationProxy(images, container=self.context,
                                               name="images")
                return proxied_images
            if name == "promotions":
                promotions = IPromotions(self.context)
                proxied_promotions = LocationProxy(promotions,
                                                   container=self.context,
                                                   name=name)
                return proxied_promotions
    
            subob = self.context.get(name)
            if subob is None:
                raise NotFound(self.context, name, request)
            return subob


Viewlet-uri, content providers
------------------------------
Folosirea content provider-ilor permite "componentizarea" paginilor web, prin
dezvoltarea de componente ce pot fi refolosite in mai multe locatii si tipuri
de obiecte context. Content provider-ii sunt implementati ca multiadapteri 
pentru context, request si view. In acest fel ei pot fi modificati per tipul 
contextului, layer-ul (sau skin-ul) asigurat de request si pagina (view-ul)
pe care se gasesc. Folosind inregistrarea acestui multiadaptor cu un nume,
el poate fi inserat in template-uri folosind expresia `provider`::

    <div tal:content="structure provider:lj.MyProvider" />

Pentru a genera continutul content provider-ilor se foloseste un proces numit
"two phase rendering". Prima data se apeleaza metoda `update` al CP-ului, apoi
metoda `render` ce genereaza continutul ce va fi inserat in pagina. 

O extensie a content providerilor sunt viewlet-urile si viewlet managerii. 
Viewlet managerii sunt content provideri ce insereaza continut in pagini. 
Diferenta fata de content providerii clasici este ca acestia, pentru generarea
continutului, folosesc niste 'mini-view-uri', viewleturile. Acestea sunt 
inregistrate ca multiadapteri ce tin cont de interfata viewlet manager-ului,
a layer-ului, a contextului si a paginii in care se doreste aparitia lor. 
Folosind aceste elemente de "discriminare" se poate controla aparitia lor.

Pachetul zope.viewlet ofera doua noi tag-uri ZCML: browser:viewletManager si
browser:viewlet. Atunci cand se inregistreaza un viewlet manager poate fi 
specificata atat clasa care il genereaza cat si un template, astfel incat 
sortarea viewlet-urilor si modul in care sunt ele inserate in pagina pot fi
modificate dupa necesitati.

Desi poate fi tentanta, ideea de a transforma o intreaga pagina si 
intreg site-ul intr-o structura bazata pe viewlet-uri este periculoasa: 
formularele in viewlet-uri sunt destul de greu de implementat, paginile vor fi 
greu de definit si greu de administrat (deoarece nu exista o imagine clara, 
in cod, a ceea ce apare pe pagina). 

Un exemplu practic:

* se defineste o interfata marker pentru viewlet manager

from zope.viewlet.interfaces import IViewletManager
class IExtraStuffBox(IViewletManager):
    '''Viewlets for the extra stuff box'''

* se inregistreaza viewlet manager-ul

    <browser:viewletManager
        name='zope3tutorial.ExtraStuffBox'
        provides='.interfaces.IExtraStuffBox'
        permission='zope.View'
        layer='.demoskin.IMySkin'
        />

* se introduce in template-ul principal:

        <div tal:replace="structure provider:zope3tutorial.ExtraStuffBox">
            A box for extra stuff
        </div>

* se scrie un viewlet:

  >>> class SizeViewlet(object):
  ...
  ...     def __init__(self, context, request, view, manager):
  ...         self.__parent__ = view
  ...         self.context = context
  ...
  ...     def update(self):
  ...         pass
  ...
  ...     def render(self):
  ...         return size.interfaces.ISized(self.context).sizeForDisplay()

  >>> zope.component.provideAdapter(
  ...     SizeViewlet,
  ...     (IFile, IDefaultBrowserLayer,
  ...      zope.interface.Interface, interfaces.IViewletManager),
  ...     interfaces.IViewlet, name='size')

In zcml inregistrarea poate fi facuta astfel: 

<browser:viewlet
    name="size"
    for="IFile"
    manager="interfaces.IViewletManager"
    class="SizeViewlet"
    permission="zope.View"
    />

* Viewlet-ul poate fi declarat si doar folosind un template

    <browser:viewlet
        name="fortune"
        for="*"
        manager='.interfaces.IExtraStuffBox'
        template='fortune.pt'
        layer='.demoskin.IMySkin'
        permission='zope.View'

        />
        
        
Template layout options when developing with Zope 3
---------------------------------------------------
A high level overview over available methods of laying out a website

When developing a Zope 2 site, the way the templates would be laid out is 
obvious: create a template for the site layout, use macros and slots to fill 
in that template and use the CMF skin overriding mechanism when you have to 
customize a certain template or Python script for another skin. Plone has been 
using this mechanism very successfully.

With Zope 3 the path is not very clear. There are several mechanisms, each 
with its advantages and disadvantages. Let's take an example website, let's 
say a multinational company website and discuss how will these various 
solutions apply.

Insert rendered HTML with TAL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This method of including content from another page (let's say template for now) 
resembles PHP's include(); I'd still call this method superior to the PHP method 
of including another page as, with Zope, you can render that page based on the 
context on which it is called:

<div tal:replace="structure context/@@footer" />

Simple, but has drawbacks: on each page of the website you'll have to "copy" 
the basic site structure and insert the specifics of the page in clearly 
delimited areas. For more then a few pages, this makes it very hard to change 
the basic website structure, as it would require changing all the pages in 
the site. Plus, you can't easily define reusable templates because you can't 
fill those templates with values except based on the context for which they 
are rendered.

METAL: Macros and Slots, just like "classic Plone"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The classic PageTemplates method of separating the site layout from the general 
page layout has been to use the METAL extension, namely macros and slots. This 
would be achieved as such:

First, we have the site template, let's call it template.pt

<html metal:define-macro="page">
    <head metal:define-slot="header">
        <title>Some title</title>
    </head>
    <body metal:define-slot="body">
        Body content comes here
    </body>
</html>

Next, we need to make this macro available. First, we publish this page under 
the "view_macros" page name and add it to the 'page_macros' tuple of the 
`standard_macros` view. Some notes about this special view: it is a special 
browser view which implements the zope.interface.common.mapping.IItemMapping 
(see for example the standard_macros.py from zope.app.basicskin and 
zope.app.rotterdam). This special view has a list of page names that provide 
macros and a list of aliases between macros (for example, you might want to 
have the "page" macro also available under the "dialog" macro name).

You then reference this macro from your page, let's say our main page of the 
website, the `page.pt` file:

<html metal:use-macro="context/@@standard_macros/page">
    <head metal:fill-slot="header">
        <title>MyTitle</title>
    </head>
    <body metal:fill-slot="body">
        Content here...
    </body>
</html>

You can, of course, add new pages that will hold macros and add them to the 
macro_pages tuple of the StandardMacros view, reference them from the 
template and so on.

Another method of getting some macros inside your templates is to reference 
that template from the browser page class. For example:

class MainPage(BrowserPage):
    macros = ViewPageTemplate('/path/to/macros.pt')

And, inside the template associated with this MainPage class:

<div metal:use-macro="view/macros/some_macro">

z3c.macro: no more bickering with standard_macros

One of the problems with the method described in the previous section is that, 
if you want to add new macro pages you need to override standard_macros in 
your skin layer or define another view to act as a macro provider. z3c.macro 
is a package that tries to overcome this by creating an easy way to register 
and retrieve new macros.

To register a new macro, let's say the `page` macro from template.pt, you'd do 
something like this:

<configure xmlns:z3c="http://namespaces.zope.org/z3c">
    <z3c:macro template="template.pt" name="page" />
</configure>

To use this macro, in our study case, inside page.pt we'd do:

<html metal:use-macro="macro:page">
...
</html>

Viewlets and content providers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let's continue developing our study website. We'll probably want a navigation 
menu for the website. If we would continue to use macros, we would develop a 
macro, insert it into the main template and be done with it. But what happens 
if we want to customize this navigation menu for just one page? Or maybe 
several special case pages... We'd have to implement a lot of logic on the 
macro, to check for the special cases, etc. Ugly and hard.

The solution in Zope 3 are the Content Providers, which, thanks to interfaces, 
would allow you to override per interface what is being rendered. They are a 
special type of zope views (as they are dependent on the browser layer) that 
provide content. For example, in our study website, a navigation menu can be 
inserted in every page by creating a content provider, something like this:

from zope.contentprovider.interfaces import IContentProvider
from zope.publisher.interfaces.browser import IDefaultBrowserLayer
from zope.publisher.interfaces.browser import IBrowserView

class MainSiteNavigation(object):
    implements(IContentProvider)
    adapts(Interface, IDefaultBrowserLayer, IBrowserView)

    def __init__(self, context, request, view):
        self.context = context
        self.request = request
        self.__parent__ = view

    def update(self):
        pass

    render = ViewPageTemplateFile('navigation.pt')

And register it like:

<adapter factory=".browser.MainSiteNavigation" name="main_site_navigation" />

Overriding this provider for, lets say, the press releases content objects, 
is a simple matter of:

class PressReleasesNavigation(object):
    adapts(IPressRelease, IDefaultBrowserLayer, IBrowserView)
    render = ViewPageTemplateFile('press_releases_navigation.pt')

And register it the same way:

<adapter 
    factory=".browser.PressReleasesNavigation" 
    name="main_site_navigation" />

Viewlets and viewlet managers are a step forward: a viewlet manager is a 
content provider for which you can register, per context interface type, 
`viewlets`. The viewlet manager then places all the rendered viewlets in 
its allocated slot in the template.

The viewlet mechanism is beneficial through the fact that you can "decouple" 
the content from the template: now you can control what "boxes" appear in 
each page by just adding/removing registrations for viewlets, no editing of 
macros, templates or code required.

Break the template from class with z3c.viewtemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let's continue with our study case website. Suppose this company has multiple 
websites, hosted one the same server, one for each country, with some shared 
content and slightly different layout and templates. In this case, multiple 
skins applied to the same Zope site are great, but you get into the pains of 
having to override (or reregister) the classes just to be able to specify a 
different template.

One of the possible solutions is the z3c.viewtemplate packages. It allows you 
to register the template separately for a view, so that you can override it, 
per browser layer.

Let's have an example. Suppose we want to be able to change the main page on 
one of the skin layers, to add another column. Presume we were using a 
MainSitePage browser page, with a main_page.pt template and now we want to 
override it. We'll need to change the MainSitePage class, something like this:

class MainSitePage(object):
    template = RegisteredPageTemplate()

    def __call__(self):
        return self.template()

or simply inherit from BaseView:

class MainSitePage(BaseView):
    ...

And now we can register a templates per browser layer:

<browser:template 
    for=".browser.MainSitePage" 
    template="main_page.pt" 
    layer=".SkinLayerOne" />

You can override the template for viewlets, too, if you inherit from a 
superclass such as this:

class BaseViewlet(object):

    template = RegisteredPageTemplate()

    def render(self):
        return self.template()

In practice you'll have something like this:

    * a main site template that will provide the layout and maybe insert 
      viewlet managers, using the standard_macros mechanism
    * the page will use the `page` macro and fill in the `content`slot of the 
      main template and only deal with the specifics of the page (there's 
      nothing special about these names, they're just the usual convention).

You can define a viewlet manager and use viewlets for the `content area`, but 
you should probably avoid this as it will probably mean that you'll have to 
deal with forms inside viewlets and this will be difficult to handle properly.

Introducing z3c.template, a better version of z3c.viewtemplate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
z3c.template is a package similar to z3c.viewtemplate (it allows separate 
registration of templates from the view code), but it also aims to separate 
the definition and registration of the layout of a page from the 
actual `content`.

Let's suppose we're implementing our site using z3c.template and we have the 
press releases page. For each page we will have a layout template and a 
content template, but we can skip the definition of the layout template by 
inheriting a base class.

The layout template will contain:

<html>
<head>
    <title tal:content="view/title" />
<head>
<body>
    <div tal:replace="view/render" />
</body>
</html>

The layout template, which, in the previous step, provided the `page` macro 
will be registered as:

<configure xmlns:z3c="http://namespaces.zope.org/z3c">
    <z3c:layout template="main_template" for=".interfaces.ISitePage" />
</configure>

We need a browser view that knows how to use the layout template and the 
content template:

class SitePage(BrowserPage):
    zope.interface.implements(ISitePage)

    template = None
    layout = None

    title = None

    def update(self):
        pass

    def render(self):
        if self.template is None:
            template = zope.component.getMultiAdapter(
                     (self, self.request), IContentTemplate)
            return template(self)
        return self.template()
    
    def __call__(self):
        self.update()
        if self.layout is None:
            layout = zope.component.getMultiAdapter((self, self.request),
                          interfaces.ILayoutTemplate)
            return layout(self)
        return self.layout()

Our view class will then inherit the SitePage class:

class PressReleaseViewPage(SitePage):

    @property
    def title(self):
        return u"Press release: " + self.context.title

And then we can simply register a content template for the class:

<configure xmlns:z3c="http://namespaces.zope.org/z3c">
    <z3c:template template="press_review_view.pt" for="IPressReview" />
</configure>

Note: z3c.template has several other features: named templates and the 
possibility to 'publish' macros from templates.

All this is very nice, but there are a couple of problems: you'll need to 
do some work to support forms, and why bother writing the SitePage class, 
when there's a package that does all this, and more? Its name is...

z3c.pagelet
~~~~~~~~~~~
This package introduces a new type of browser page: pagelet. A pagelet is a 
page with a layout template: you define the layout with the mechanisms 
introduced in z3c.template, but the `SitePage` base class is no longer 
necessary, as it is provided by the z3c.pagelet package. Inside the layout 
template you include the `pagelet` content provider:

<div tal:replace="structure provider: pagelet" />

The list of goodies continues: the package includes replacements for the 
formlib base classes: EditForm, AddForm and so on. Even more, using 
z3c.skin.pagelet you get a starter skin that has all the bits in place to 
bootstrap developing a pagelet based website (including, for 
example, "pagelet-ified" exception pages).

To register a pagelet you do something like (notice the similarity to a 
browser:page registration):

  <z3c:pagelet
      name="index.html"
      for=".interfaces.PressRelease"
      class=".views.IndexPagelet"
      layer=".interfaces.ICompanyWebsiteLayer"
      permission="zope.View"
      />

More pointers and packages

    * z3c.macroviewlet - Allows you to write the a complete template of the 
      website in one file and also define some of the macros of this 
      template as viewlets.
    * z3c.pt: a faster version of PageTemplates, but with several restrictions 
      (no macro support, no TAL paths and expressions)
    * gocept.form: contains integration of z3c.form with z3c.pagelet
    * z3c.formui: Use overridable templates with z3c.form using the 
      z3c.template mechanism
      

      
      
Slides
------
* Administrarea serverului prin ZMI
* Crearea unui pachet python si incarcarea ca si extensie Zope
    * paster create -t zope
    * ZCML, namespace-uri zcml
        * dotted names, package resolution
        * overriding zcml
        * http://namespaces.zope.org/zope
        * http://namespaces.zope.org/browser
        * http://xml.zope.org/namespaces/tal
        * Scrierea unei extensii zcml
        * Martian (configurare fara zcml)
* Citirea documentatiei Zope (apidoc, introspectie, README-uri)
    * APIDOC (http://localhost:8080/++apidoc++,
              http://apidoc.zope.org/++apidoc++/)
* Pagini simple: obiectul request, response, form-uri manuale, formuri automate
    * Inregistrarea de actiuni noi pentru ZMI (menuri)
    * Error logging, debugging
* View-uri, agregare view-uri in pagini
* Zope Component Architecture
    * zope.interface
        * componentele sunt obiectele care asigura una sau mai multe interfete.
        Pe baza interfetei putem sa identificam tipul unui obiect, indiferent de
        clasa care l-a produs. Cu ajutorul interfetelor putem sa interogam
        aspecte ale altor obiecte, chiar daca aparent nu au legatura cu
        interfata noastra. Exemplul cu ISized
        * zope.schema
    * Adaptori, multi-adaptori
        * Trusted adapters, locatable adapters
    * Utilitare globale, utilitare locale
    * Subscriberi, handlere
        * evenimente
    * Site-uri locale
    * z3c.baseregistry
* Validarea obiectelor cu FieldProperty
* Containere, restrictionarea continutului in containere
* Indexarea obiectelor pentru cautare rapida
    * unique ids
    * indexarea se face pe baza interfetei
    * Extensiile sunt usor de scris
    * zope.app.catalog
    * zc.catalog
    * lovely.catalog
    * hurry.query
    * textindexng
    * integrare solr, xapian, lucene
* Anotarea obiectelor
    * IAttributeAnnotatable
* IZopeDublinCore mappings
* Crearea si folosirea de macro pages
* Internationalizarea interfetei
    * se foloseste standardul gettext
    * utilitare folosite
    * message domains in ZCML
    * localizare
* Internationalizarea continutului cu z3c.language.switch
* Crearea unui layer nou, a unui skin nou
    * z3c.layer.minimal
    * reinregistrarea unei pagini per layer
* Securitate, permisiuni
    * Declararea de roluri si permisiuni
    * Roluri si permisiuni alocate local
* Formulare cu zope.formlib
    * Add, Edit, generarea din interfete multiple, adaptarea contextului
    * vocabulare
    * editarea de obiecte tranziente
    * crearea unui field type si a unui widget
    * patern-uri AJAX
    * template-uri modificate
* Content providers, viewlet-uri, viewlet manager
* Relatii intre obiecte cu z3c.relationfield
* Autentificare cu PAU
    * diferenta dintre Principal si InternalPrincipal
* Custom traversing: z3c.traverser
* Extinderea cu parametri a content providerilor
* Migrarea bazei de date cu generations
* Setari pentru apache, nginx
* Construirea de aplicatii cu zc.buildout
    * virtualenv

    
A Comprehensive Guide to Zope Component Architecture
----------------------------------------------------
Un document bogat in exemple si explicatii despre Zope Component Architecture,
configurarea cu zcml si modul in care poate fi folosita in orice aplicatie
Python, nu doar Zope.
 
Locatie: http://www.muthukadan.net/docs/zca.html


Ghid al pachetelor 3rd party Zope
---------------------------------
http://wiki.zope.org/zope3/Zope3PackageGuide


Zope 3 Book
-----------
Desi pare invechita, o buna parte din ceea ce exista in aceasta carte este inca
valabil http://wiki.zope.org/zope3/Zope3Book

Worldcookery
------------
Sectiunea Downloads contine codul sursa sub licenta GPL, si reprezinta o foarte
buna resursa pentru intelegerea Zope.
http://worldcookery.com/Downloads
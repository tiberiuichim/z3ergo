Modalitati de rezolvare a unor probleme tipice
==============================================

* Administrarea serverului prin ZMI
* Crearea unui pachet python si incarcarea ca si extensie Zope
    * paster create -t zope
    * ZCML, namespace-uri zcml
        * dotted names, package resolution
        * overriding zcml
        * http://namespaces.zope.org/zope
        * http://namespaces.zope.org/browser
        * http://xml.zope.org/namespaces/tal
        * Scrierea unei extensii zcml
        * Martian (configurare fara zcml)
* Citirea documentatiei Zope (apidoc, introspectie, README-uri)
    * APIDOC (http://localhost:8080/++apidoc++,
              http://apidoc.zope.org/++apidoc++/)
* Pagini simple: obiectul request, response, form-uri manuale, formuri automate
    * Inregistrarea de actiuni noi pentru ZMI (menuri)
    * Error logging, debugging
* View-uri, agregare view-uri in pagini
* Zope Component Architecture
    * zope.interface
        * componentele sunt obiectele care asigura una sau mai multe interfete.
        Pe baza interfetei putem sa identificam tipul unui obiect, indiferent de
        clasa care l-a produs. Cu ajutorul interfetelor putem sa interogam
        aspecte ale altor obiecte, chiar daca aparent nu au legatura cu
        interfata noastra. Exemplul cu ISized
        * zope.schema
    * Adaptori, multi-adaptori
        * Trusted adapters, locatable adapters
    * Utilitare globale, utilitare locale
    * Subscriberi, handlere
        * evenimente
    * Site-uri locale
    * z3c.baseregistry
* Validarea obiectelor cu FieldProperty
* Containere, restrictionarea continutului in containere
* Indexarea obiectelor pentru cautare rapida
    * unique ids
    * indexarea se face pe baza interfetei
    * Extensiile sunt usor de scris
    * zope.app.catalog
    * zc.catalog
    * lovely.catalog
    * hurry.query
    * textindexng
    * integrare solr, xapian, lucene
* Anotarea obiectelor
    * IAttributeAnnotatable
* IZopeDublinCore mappings
* Crearea si folosirea de macro pages
* Internationalizarea interfetei
    * se foloseste standardul gettext
    * utilitare folosite
    * message domains in ZCML
    * localizare
* Internationalizarea continutului cu z3c.language.switch
* Crearea unui layer nou, a unui skin nou
    * z3c.layer.minimal
    * reinregistrarea unei pagini per layer
* Securitate, permisiuni
    * Declararea de roluri si permisiuni
    * Roluri si permisiuni alocate local
* Formulare cu zope.formlib
    * Add, Edit, generarea din interfete multiple, adaptarea contextului
    * vocabulare
    * editarea de obiecte tranziente
    * crearea unui field type si a unui widget
    * patern-uri AJAX
    * template-uri modificate
* Content providers, viewlet-uri, viewlet manager
* Relatii intre obiecte cu z3c.relationfield
* Autentificare cu PAU
    * diferenta dintre Principal si InternalPrincipal
* Custom traversing: z3c.traverser
* Extinderea cu parametri a content providerilor
* Migrarea bazei de date cu generations
* Setari pentru apache, nginx
* Construirea de aplicatii cu zc.buildout
    * virtualenv


Folosirea anotarilor si a relatiilor
------------------------------------ 
Avand un folder cu imagini de pe circuitele de curse de masini, dorim sa 
asignam o lista de imagini unor obiecte de tipul Pilor, Echipa sau Stadion.

class IHasImages(Interface):
   """marker, objects have pointers to images"""

class Pilot:
   implements(IHasImages, IAttributeAnnotatable)
   #e gresit sa pui IHasImage sa faca inherit la AttributeAnnotatable
   #HasImages tine de comportament, AttributeAnnotatable tine deja de implementarea anotarilor

class Team(Persistent):
   implements(IHasImages, IAttributeAnnotatable)

class Stadium(Persistent):
   implements(IHasImages, IAttributeAnnotatable)
   
class PicturesAlbum(BTreeContainer): 
   contains(IImage)

class IPicturesInfo(Interface):
   images = List(title=u"Image",
                 value_type=Relation(title="Relation")
                 )

class PicturesInfoAnotation(Persistent):
   images = None
   
from zope.annotation.factory import factory
annotation_factory = factory(PicturesInfoAnotation, 'images_pointers')

Exemple de folosire a relatiilor folosind anotarea:
             
IPicturesInfo(pilot_instance).images.append(img) 
del IPicturesInfo(team_instance).images[1] 


Internationalizarea continutului cu z3c.language.switch
-------------------------------------------------------
class BusinessI18NInfo(Persistent):
    """The business content object"""

    name = FieldProperty(IBusiness['name'])
    address = FieldProperty(IBusiness['address'])
    description = FieldProperty(IBusiness['description'])
    promo_message = FieldProperty(IBusiness['promo_message'])


class Business(I18n, BTreeContainer, Contained):
    """ """
    _factory = BusinessI18NInfo
    _defaultLanguage = 'en'

    implements(IBusiness)

    name = I18nFieldProperty(IBusiness['name'])
    address = I18nFieldProperty(IBusiness['address'])
    description = I18nFieldProperty(IBusiness['description'])
    promo_message = I18nFieldProperty(IBusiness['promo_message'])

    def queryAttribute(self, name, language=None, default=None):
        #override so that we never return empty stuff
        value = super(Business, self).queryAttribute(name, language, default=None)
        if value is None:
            negotiator = getUtility(INegotiator, context=self)
            lang = negotiator.serverLanguage
            try:
                value = self.getAttribute(name, language=lang)
            except KeyError:
                pass
        if value is None:
            #try to return something meaningful
            langs = self.getAvailableLanguages()
            if langs:
                lang = langs[0]
            try:
                value = self.getAttribute(name, language=lang)
            except KeyError:
                pass
        if value is not None:
            return value
        else:
            return default
            
            
Modificarea traversarii cu z3c.traverser
----------------------------------------
Traversing to business/images will return the annotation of BusinessImagesAlbum 
for the Business

  <subscriber
    for="lovely.reviewportal.app.interfaces.IBusiness
         zope.publisher.interfaces.browser.IBrowserRequest"
    provides="z3c.traverser.interfaces.ITraverserPlugin"
    factory=".traversing.BussinesTraverserPlugin" />

    
class BussinesTraverserPlugin(ContainerTraverserPlugin):
    """Traverser that returns the images album at business/images/ for a Business
    """

    def publishTraverse(self, request, name):
        if name == "images":
            images = IBusinessImagesAlbum(self.context)
            proxied_images = LocationProxy(images, container=self.context,
                                           name="images")
            return proxied_images
        if name == "promotions":
            promotions = IPromotions(self.context)
            proxied_promotions = LocationProxy(promotions,
                                               container=self.context,
                                               name=name)
            return proxied_promotions

        subob = self.context.get(name)
        if subob is None:
            raise NotFound(self.context, name, request)
        return subob


Viewlet-uri, content providers
------------------------------
Folosirea content provider-ilor permite "componentizarea" paginilor web, prin
dezvoltarea de componente ce pot fi refolosite in mai multe locatii si tipuri
de obiecte context. Content provider-ii sunt implementati ca multiadapteri 
pentru context, request si view. In acest fel ei pot fi modificati per tipul 
contextului, layer-ul (sau skin-ul) asigurat de request si pagina (view-ul)
pe care se gasesc. Folosind inregistrarea acestui multiadaptor cu un nume,
el poate fi inserat in template-uri folosind expresia `provider`:

<div tal:content="structure provider:lj.MyProvider" />

Pentru a genera continutul content provider-ilor se foloseste un proces numit
"two phase rendering". Prima data se apeleaza metoda `update` al CP-ului, apoi
metoda `render` ce genereaza continutul ce va fi inserat in pagina. 

O extensie a content providerilor sunt viewlet-urile si viewlet managerii. 
Viewlet managerii sunt content provideri ce insereaza continut in pagini. 
Diferenta fata de content providerii clasici este ca acestia, pentru generarea
continutului, folosesc niste 'mini-view-uri', viewleturile. Acestea sunt 
inregistrate ca multiadapteri ce tin cont de interfata viewlet manager-ului,
a layer-ului, a contextului si a paginii in care se doreste aparitia lor. 
Folosind aceste elemente de "discriminare" se poate controla aparitia lor.

Pachetul zope.viewlet ofera doua noi tag-uri ZCML: browser:viewletManager si
browser:viewlet. Atunci cand se inregistreaza un viewlet manager poate fi 
specificata atat clasa care il genereaza cat si un template, astfel incat 
sortarea viewlet-urilor si modul in care sunt ele inserate in pagina pot fi
modificate dupa necesitati.

